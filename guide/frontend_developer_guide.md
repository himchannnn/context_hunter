# Context Hunter - 프론트엔드 개발자 가이드

## 1. 프로젝트 개요
**Context Hunter**는 문맥 추론을 통해 문해력을 향상시키는 React 기반의 교육용 게임입니다. 최신 웹 기술을 사용하여 모바일 친화적인 디자인을 구현했으며, AI 기반 백엔드와의 매끄러운 연동이 특징입니다.

### 기술 스택 (Tech Stack)
-   **프레임워크**: [React 18](https://react.dev/) + [Vite](https://vitejs.dev/)
-   **언어**: TypeScript
-   **스타일링**: [Tailwind CSS](https://tailwindcss.com/)
-   **아이콘**: [Lucide React](https://lucide.dev/)

---

## 2. 디렉토리 구조 (`app/src`)

```
src/
├── components/          # UI 컴포넌트 및 화면(Screens)
│   ├── GameScreen.tsx   # 핵심 게임 플레이 로직
│   ├── MainScreen.tsx   # 메인 대시보드 및 모드 선택
│   ├── ...              # 기타 화면 (로그인, 상점, 결과 화면 등)
├── context/             # 전역 상태 관리 (Context API)
│   ├── AuthContext.tsx  # 사용자 인증 및 게스트 모드 관리
│   └── SoundContext.tsx # 효과음 관리
├── lib/                 # 유틸리티
│   └── api.ts           # 백엔드 API 연동 (Axios/Fetch 래퍼)
├── styles/              # 전역 스타일
├── App.tsx              # 메인 엔트리 포인트 및 라우팅 (상태 기반 라우팅)
└── types.ts             # 공용 타입 정의 (User, Question, GameState 등)
```

---

## 3. 아키텍처 및 핵심 로직

### A. 라우팅 (State-Based Routing)
`react-router-dom`을 사용하는 일반적인 웹앱과 달리, 이 프로젝트는 **단일 상태 기반 라우팅** 방식을 사용합니다. 모든 화면 전환은 `App.tsx`에서 중앙 제어됩니다.

-   **`gameState`**: 현재 어떤 화면을 보여줄지 결정하는 핵심 State입니다.
    -   값: `'main' | 'difficulty' | 'playing' | 'result' | 'shop' ...`
-   **이유**: 게임 도중 뒤로가기를 눌러 이탈하는 것을 방지하고, 게임의 흐름(Flow)을 엄격하게 제어하여 몰입감을 높이기 위함입니다.

### B. 인증 흐름 (`AuthContext`)
-   **하이브리드 시스템**: **게스트(비회원)**와 **회원**을 모두 지원합니다.
-   **게스트 모드**: 별도 가입 절차 없이 `guest_xyz` 형태의 임시 ID를 발급받아 즉시 게임을 즐길 수 있습니다. 이는 사용자의 진입 장벽을 없애는 핵심 UX입니다.
-   **토큰 저장**: JWT `access_token`은 `localStorage`에 저장하여 세션을 유지합니다.

### C. 게임 루프 (`GameScreen.tsx`)
애플리케이션의 심장부입니다.
1.  **초기화**: `api.fetchQuestions()`를 호출하여 문제 세트를 불러옵니다.
2.  **플레이**:
    -   사용자가 자신의 해석(답안)을 입력합니다.
    -   **AI 검증**: `api.verifyAnswer()`를 호출하여 사용자의 문장을 백엔드 LLM으로 전송합니다.
    -   **피드백**: 백엔드는 단순 정답 여부(`isCorrect`)뿐만 아니라 유사도 점수(`similarity`)와 텍스트 피드백(`feedback`)을 반환합니다.
3.  **상태 업데이트**: 결과에 따라 연속 정답(Streak), 생명(Lives, 도전모드), 진행률(일일모드)을 실시간으로 업데이트합니다.

---

## 4. 주요 컴포넌트 분석

### `App.tsx` (컨트롤 타워)
-   **역할**: 앱의 최상위 컨트롤러입니다. (MVC 패턴의 Controller와 유사)
-   **기능**:
    -   전역 `gameState` 관리
    -   배경 테마(`ThemeBackground`) 동적 렌더링
    -   화면 간 전환 처리 및 모달 관리

### `MainScreen.tsx` (대시보드)
-   **역할**: 사용자가 처음 마주하는 화면입니다.
-   **기능**:
    -   게임 모드 선택 (일일 도전 vs 무한 도전)
    -   미니 명예의 전당 (비동기 데이터 로딩)
    -   상점, 오답노트 등으로의 진입점 제공

### `GameScreen.tsx` (게임 엔진)
-   **역할**: 실제 퀴즈와 상호작용하는 UI입니다.
-   **핵심 함수**:
    -   **`handleNext`**: 다음 문제로 넘어가거나 게임을 종료하는 흐름 제어.
    -   **`handleSubmit`**: 답안 제출 시 UI 잠금(Loading), 효과음 재생, 결과 처리를 담당.
    -   **`Feedback UI`**: 정답/오답에 따라 초록/빨강 색상 테마로 즉각 변환되며, 오답 시 흔들림(Shake) 애니메이션을 적용.

### `DomainSelector.tsx`
-   **역할**: '일일 도전' 모드의 카테고리 선택 화면입니다.
-   **로직**: 서버에서 `UserProgress`를 받아와 이미 클리어한 분야에는 '완료 배지'를 표시합니다.

---

## 5. API 연동 (`lib/api.ts`)
모든 백엔드 통신은 이 모듈에 중앙집중화되어 있습니다. 컴포넌트 내부에서 직접 `fetch`를 호출하지 않습니다.

**주요 함수:**
-   `fetchQuestions()`: 난이도/분야에 맞춰 문제 세트를 가져옵니다.
-   `verifyAnswer()`: **가장 중요한 함수**. 사용자의 문장을 LLM에게 보내 의미적 유사도를 판단합니다.
-   `fetchRankings()`: 리더보드 데이터를 가져옵니다.

---

## 6. 스타일링 전략
-   **Tailwind CSS**: 99%의 스타일링에 사용되었습니다.
-   **모바일 퍼스트**: `p-4 md:p-8`과 같은 반응형 클래스를 사용하여 모바일과 데스크톱 모두에서 깨지지 않는 UI를 구현했습니다.
-   **동적 테마**: 사용자가 상점에서 구매한 테마(`user.equipped_theme`)에 따라 앱 전체의 배경과 분위기가 바뀝니다.

---

## 7. 발표 및 설명 팁 (Q&A 대비)

**Q. "AI 기능은 정확히 어떻게 동작하나요?"**
> "프론트엔드는 단순히 텍스트를 전달하는 클라이언트 역할을 합니다. 사용자가 문장을 입력하면, 단순한 텍스트 매칭이 아니라 백엔드의 LLM(거대언어모델)이 문맥적 의미를 분석합니다. 프론트엔드는 이 복잡한 분석 결과를 사용자가 이해하기 쉬운 '점수'와 '피드백'으로 즉시 시각화하여 보여줍니다."

**Q. "이 프로젝트의 확장성은 어떤가요?"**
> "`gameState` 기반의 모듈형 구조를 가지고 있어 확장이 매우 용이합니다. 예를 들어 '타임 어택 모드'를 추가하고 싶다면, `GameScreen`을 복사해 로직을 조금 수정한 뒤 `App.tsx`에 새로운 상태만 추가하면 됩니다. 기존 코드를 뜯어고칠 필요가 없습니다."

**Q. "사용자 경험(UX)에서 가장 신경 쓴 부분은?"**
> "'즉각적인 반응'입니다. 게스트 모드를 통해 1초 만에 게임을 시작할 수 있게 했고, 답안 제출 시 AI의 판단 결과를 기다리는 동안 지루하지 않도록 로딩 인디케이터와 애니메이션 효과를 적절히 배치하여 '게임'다운 손맛을 살렸습니다."
